import { Token } from './token';
import * as ESTree from './estree';
import { Context, ParserState, PropertyKind, BindingOrigin, FunctionStatement, ParseFunctionFlag, BindingType } from './common';
export declare function create(source: string): ParserState;
export interface Options {
    module?: boolean;
    next?: boolean;
    ranges?: boolean;
    webCompat?: boolean;
    loc?: boolean;
    raw?: boolean;
    directives?: boolean;
    globalReturn?: boolean;
    globalAwait?: boolean;
    impliedStrict?: boolean;
}
export declare function parseSource(source: string, options: Options | void, context: Context): ESTree.Program;
export declare function parseStatementList(parser: ParserState, context: Context): ESTree.Statement[];
export declare function parseModuleItem(parser: ParserState, context: Context): (ReturnType<typeof parseDirective | typeof parseparseModuleItemList>)[];
export declare function parseparseModuleItemList(parser: ParserState, context: Context): any;
export declare function parseStatementListItem(parser: ParserState, context: Context): ESTree.Statement | ESTree.Decorator[];
export declare function parseStatement(parser: ParserState, context: Context, allowFuncDecl: FunctionStatement): ESTree.Statement;
export declare function parseExpressionOrLabelledStatement(parser: ParserState, context: Context, allowFuncDecl: FunctionStatement): ESTree.ExpressionStatement | ESTree.LabeledStatement;
export declare function parseBlock(parser: ParserState, context: Context): ESTree.BlockStatement;
export declare function parseReturnStatement(parser: ParserState, context: Context): ESTree.ReturnStatement;
export declare function parseExpressionStatement(parser: ParserState, context: Context, expr: ESTree.Expression): ESTree.ExpressionStatement;
export declare function parseLabelledStatement(parser: ParserState, context: Context, expr: ESTree.Identifier, token: Token, allowFuncDecl: 0 | 1): ESTree.LabeledStatement;
export declare function parseAsyncArrowOrAsyncFunctionDeclaration(parser: ParserState, context: Context, allowFuncDecl: FunctionStatement): ESTree.ExpressionStatement | ESTree.LabeledStatement | ESTree.FunctionDeclaration;
export declare function parseDirective(parser: ParserState, context: Context): ESTree.Statement | ESTree.ExpressionStatement;
export declare function parseEmptyStatement(parser: ParserState, context: Context): ESTree.EmptyStatement;
export declare function parseThrowStatement(parser: ParserState, context: Context): ESTree.ThrowStatement;
export declare function parseIfStatement(parser: ParserState, context: Context): ESTree.IfStatement;
export declare function parseConsequentOrAlternate(parser: ParserState, context: Context): ESTree.Statement | ESTree.FunctionDeclaration;
export declare function parseSwitchStatement(parser: ParserState, context: Context): ESTree.SwitchStatement;
export declare function parseWhileStatement(parser: ParserState, context: Context): ESTree.WhileStatement;
export declare function parseContinueStatement(parser: ParserState, context: Context): ESTree.ContinueStatement;
export declare function parseBreakStatement(parser: ParserState, context: Context): ESTree.BreakStatement;
export declare function parseWithStatement(parser: ParserState, context: Context): ESTree.WithStatement;
export declare function parseDebuggerStatement(parser: ParserState, context: Context): ESTree.DebuggerStatement;
export declare function parseTryStatement(parser: ParserState, context: Context): ESTree.TryStatement;
export declare function parseCatchBlock(parser: ParserState, context: Context): ESTree.CatchClause;
export declare function parseDoWhileStatement(parser: ParserState, context: Context): ESTree.DoWhileStatement;
export declare function parseLetIdentOrVarDeclarationStatement(parser: ParserState, context: Context): ESTree.VariableDeclaration | ESTree.LabeledStatement | ESTree.ExpressionStatement;
export declare function parseVariableStatement(parser: ParserState, context: Context, type: BindingType, origin: BindingOrigin): ESTree.VariableDeclaration;
export declare function parseVariableDeclarationList(parser: ParserState, context: Context, type: BindingType, origin: BindingOrigin): ESTree.VariableDeclarator[];
export declare function parseForStatement(parser: ParserState, context: Context): ESTree.ForStatement | ESTree.ForInStatement | ESTree.ForOfStatement;
export declare function parseExpression(parser: ParserState, context: Context, assignable: 0 | 1): ESTree.Expression;
export declare function parseSequenceExpression(parser: ParserState, context: Context, expr: ESTree.AssignmentExpression | ESTree.Expression): ESTree.SequenceExpression;
export declare function parseExpressions(parser: ParserState, context: Context, assignable: 0 | 1): ESTree.SequenceExpression | ESTree.Expression;
export declare function parseAssignmentExpression(parser: ParserState, context: Context, left: ESTree.AssignmentExpression | ESTree.LogicalExpression | ESTree.BinaryExpression | ESTree.Identifier | ESTree.Literal | ESTree.ConditionalExpression): ESTree.AssignmentExpression | ESTree.LogicalExpression | ESTree.BinaryExpression | ESTree.Identifier | ESTree.Literal | ESTree.ConditionalExpression;
export declare function parseConditionalExpression(parser: ParserState, context: Context, test: ESTree.Expression): ESTree.ConditionalExpression;
export declare function parseBinaryExpression(parser: ParserState, context: Context, minPrec: number, left: ESTree.AssignmentExpression | ESTree.BinaryExpression | ESTree.LogicalExpression | ESTree.Identifier | ESTree.Literal | ESTree.ConditionalExpression): ESTree.AssignmentExpression | ESTree.LogicalExpression | ESTree.BinaryExpression | ESTree.Identifier | ESTree.Literal | ESTree.ConditionalExpression;
export declare function parseUnaryExpression(parser: ParserState, context: Context): ESTree.UnaryExpression;
export declare function parseYieldExpressionOrIdentifier(parser: ParserState, context: Context): any;
export declare function parseAwaitExpressionOrIdentifier(parser: ParserState, context: Context, inNewExpression: 0 | 1): ESTree.Identifier | ESTree.Expression | ESTree.ArrowFunctionExpression | ESTree.AwaitExpression;
export declare function parseFunctionBody(parser: ParserState, context: Context, origin: BindingOrigin, firstRestricted: Token | undefined): ESTree.BlockStatement;
export declare function parseSuperExpression(parser: ParserState, context: Context): ESTree.Super;
export declare function parseLeftHandSideExpression(parser: ParserState, context: Context, assignable: 0 | 1): any;
export declare function parseMemberOrUpdateExpression(parser: ParserState, context: Context, expr: ESTree.Expression, inNewExpression: 0 | 1): any;
export declare function parsePrimaryExpressionExtended(parser: ParserState, context: Context, type: BindingType, inNewExpression: 0 | 1, assignable: 0 | 1): any;
export declare function parseBigIntLiteral(parser: ParserState, context: Context): ESTree.Literal;
export declare function parseTemplateLiteral(parser: ParserState, context: Context): ESTree.TemplateLiteral;
export declare function parseTemplateTail(parser: ParserState, context: Context): ESTree.TemplateElement;
export declare function parseTemplate(parser: ParserState, context: Context): ESTree.TemplateLiteral;
export declare function parseTemplateSpans(parser: ParserState, tail: boolean): ESTree.TemplateElement;
export declare function parseArguments(parser: ParserState, context: Context): (ESTree.SpreadElement | ESTree.Expression)[];
export declare function parseIdentifier(parser: ParserState, context: Context): ESTree.Identifier;
export declare function parseLiteral(parser: ParserState, context: Context): ESTree.Literal;
export declare function parseNullOrTrueOrFalseLiteral(parser: ParserState, context: Context): ESTree.Literal;
export declare function parseThisExpression(parser: ParserState, context: Context): ESTree.ThisExpression;
export declare function parseFunctionDeclaration(parser: ParserState, context: Context, flags: ParseFunctionFlag, isAsync: 0 | 1): ESTree.FunctionDeclaration;
export declare function parseFunctionExpression(parser: ParserState, context: Context, isAsync: 0 | 1): ESTree.FunctionExpression;
export declare function parseArrayExpressionOrPattern(parser: ParserState, context: Context, skipInitializer: 0 | 1, type: BindingType): ESTree.ArrayExpression | ESTree.ArrayPattern;
export declare function parseMethodDefinition(parser: ParserState, context: Context, kind: PropertyKind): ESTree.FunctionExpression;
export declare function parseObjectLiteralOrPattern(parser: ParserState, context: Context, skipInitializer: 0 | 1, type: BindingType): ESTree.ObjectExpression | ESTree.ObjectPattern | ESTree.AssignmentExpression;
export declare function parseMethodFormals(parser: ParserState, context: Context, kind: PropertyKind, type: BindingType): any[];
export declare function parseComputedPropertyName(parser: ParserState, context: Context): ESTree.Expression;
export declare function parseParenthesizedExpression(parser: ParserState, context: Context, assignable: 0 | 1): any;
export declare function parseIdentifierOrArrow(parser: ParserState, context: Context, expr: ESTree.Identifier): ESTree.Identifier | ESTree.ArrowFunctionExpression;
export declare function parseArrowFunctionExpression(parser: ParserState, context: Context, params: ESTree.Pattern[], isAsync: 0 | 1): ESTree.ArrowFunctionExpression;
export declare function parseFormalParametersOrFormalList(parser: ParserState, context: Context, type: BindingType): any[];
export declare function parseNewExpression(parser: ParserState, context: Context): ESTree.NewExpression | ESTree.Expression | ESTree.MetaProperty;
export declare function parseMetaProperty(parser: ParserState, context: Context, meta: ESTree.Identifier): ESTree.MetaProperty;
export declare function parseAsyncExpression(parser: ParserState, context: Context, expr: ESTree.Identifier, inNewExpression: 0 | 1, assignable: 0 | 1): ESTree.Expression;
export declare function parseAsyncArrowOrCallExpression(parser: ParserState, context: Context, callee: ESTree.Identifier | void, assignable: 0 | 1, asyncNewLine: 0 | 1): any;
export declare function parseRegExpLiteral(parser: ParserState, context: Context): ESTree.RegExpLiteral;
export declare function parseClassDeclaration(parser: ParserState, context: Context, requireIdentifier: 0 | 1): ESTree.ClassDeclaration;
export declare function parseClassExpression(parser: ParserState, context: Context): ESTree.ClassExpression;
export declare function parseDecorators(parser: ParserState, context: Context): ESTree.Decorator[];
export declare function parseClassBody(parser: ParserState, context: Context, type: BindingType, origin: BindingOrigin, decorators: ESTree.Decorator[]): ESTree.ClassBody;
export declare function parseFieldDefinition(parser: ParserState, context: Context, key: ESTree.PrivateName | ESTree.Expression | null, state: PropertyKind, decorators: ESTree.Decorator[] | null): ESTree.FieldDefinition;
export declare function parseBindingPattern(parser: ParserState, context: Context, type: BindingType): any;
//# sourceMappingURL=parser.d.ts.map